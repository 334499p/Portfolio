using System.Collections; using System.Collections.Generic; using UnityEngine; using System; using System.Threading;  public class ThreadedLODS : MonoBehaviour {      public static ThreadedLODS instance;      public ThreadedObjectInfo[] objectLODInfos;     [HideInInspector] public List<ThreadedObstacle> threadedObstacles = new List<ThreadedObstacle>();      [SerializeField] Transform camT;     [SerializeField] Transform remover;     [SerializeField] float removerRadius = 1;      LODObject[] lodObjects; //Main thread sets up the foundation of this, worker thread modifies it     ObjectData[] objectDatas; //The worker thread uses this      //Worked thread uses this     Vector3 camPos, camDir;     Queue<Vector3> removePoints = new Queue<Vector3>();
 
	private void Awake()
	{
        instance = this;
	}
	// Use this for initialization
	void Start()     {                  objectDatas = new ObjectData[6000];         for (int i = 0; i < 6000; i++)         {             ObjectData data = new ObjectData();             data.position = UnityEngine.Random.insideUnitSphere * 10;             data.rotation = UnityEngine.Random.rotation;             data.scale = new Vector3(1, 1, 1);             data.currentLOD = -1;             //if (UnityEngine.Random.Range(0, 100) < 80)                 data.id = 0;            // else             //{                 //data.id = 1;                // data.position = UnityEngine.Random.insideUnitSphere * 20;             // }              data.matrix = Matrix4x4.TRS(data.position, data.rotation, data.scale);                           objectDatas[i] = data;         }          Setup();          // Begin worker thread         _thread = new Thread(ThreadedWork);         _thread.Start();          _thread2 = new Thread(ThreadedWorkCulling);         _thread2.Start();          _thread3 = new Thread(ThreadedWorkCulling2);         _thread3.Start();     }
	     void Setup(){         lodObjects = new LODObject[objectLODInfos.Length];         for (int i = 0; i < objectLODInfos.Length; i++)         { //for each object type             lodObjects[i] = new LODObject();             for (int x = 0; x < objectLODInfos[i].meshes.Length; x++)             {                 lodObjects[i].lodElements.Add(new LODElement()); //The worker thread only needs this set up - It will then assign the splintered matrix list             }         }     }
    BetterVector3 zeroVector = new BetterVector3(0, 0, 0); 
	// Update is called once per frame
	void Update()     {          removePoints.Enqueue(remover.position);          camPos = camT.position;         camDir = camT.forward;          int lodObjectsCount = lodObjects.Length;         for (int objectID = 0; objectID < lodObjectsCount; objectID++)
        {             int lodElementsCount = lodObjects[objectID].lodElements.Count;             for (int lodID = 0; lodID < lodElementsCount; lodID++)
            {                 Mesh mesh = objectLODInfos[objectID].meshes[lodID];                 Material mat = objectLODInfos[objectID].materials[lodID];                 LODElement lod = lodObjects[objectID].lodElements[lodID];                 for (int matrixID = 0; matrixID < lodObjects[objectID].lodElements[lodID].splinteredMatrixLists.Count; matrixID++)
                {
                    Graphics.DrawMeshInstanced(mesh, 0, mat, lod.splinteredMatrixLists[matrixID].matrixData);                 }             }         }     }      bool _threadRunning = true;     Thread _thread, _thread2, _thread3;  
	void ThreadedWork()     {         _threadRunning = true;         bool workDone = false;          // This pattern lets us interrupt the work at a safe point if neeeded.         while (_threadRunning && !workDone)         {              Thread.Sleep(1);             Vector3 pointToRemove = Vector3.zero;              bool hasPointToRemove = false;              if (removePoints.Count != 0)             {                 pointToRemove = removePoints.Dequeue();                 hasPointToRemove = true;             }              for (int objectIndex = 0; objectIndex < objectDatas.Length; objectIndex++)             { //for each object                 ObjectData thisObject = objectDatas[objectIndex];                 bool culled = thisObject.culled;                 bool hidden = thisObject.hidden;                 if (thisObject.rendering == false)                     continue;                   Vector3 objectPosition = thisObject.position;                  float xDif = objectPosition.x - camPos.x;                 float yDif = objectPosition.y - camPos.y;                 float zDif = objectPosition.z - camPos.z;                 thisObject.dirX = xDif;                 thisObject.dirY = yDif;                 thisObject.dirZ = zDif;                  float distance = (float)System.Math.Sqrt(xDif * xDif + yDif * yDif + zDif * zDif);                  float xNorm = xDif / distance;                 float yNorm = yDif / distance;                 float zNorm = zDif / distance;                  thisObject.dirNormX = xNorm;                 thisObject.dirNormY = yNorm;                 thisObject.dirNormZ = zNorm;                  thisObject.distanceFromCamera = distance;                  int objectLOD = thisObject.currentLOD;                 int objectID = thisObject.id;                 int lodAddingTo = -1;                   if (hasPointToRemove)                 {                     float dist = Vector3.Distance(thisObject.position, pointToRemove);                     if (dist < removerRadius)                     {                         thisObject.rendering = false;                         culled = true;                     }                 }                  if (!culled && !hidden)                 {                     LODObject lodObject = lodObjects[objectID];                     for (int lodIndex = 0; lodIndex < objectLODInfos[objectID].renderDistances.Length; lodIndex++)                     {                         if (distance < objectLODInfos[objectID].renderDistances[lodIndex])                         {                             if (objectLOD != lodIndex)                             {                                 lodObject.lodElements[lodIndex].AddMatrix(thisObject.matrix, objectIndex);                             }                             lodAddingTo = lodIndex;                             break;                         }                     }                 }                 else                 {                     lodAddingTo = -1;                 }                 if (objectLOD != -1)                 {                     if (lodAddingTo != objectLOD)                         lodObjects[objectID].lodElements[objectLOD].RemoveMatrix(objectIndex);                 }                 thisObject.currentLOD = lodAddingTo;             }                                     // Do Work...         }         _threadRunning = false;     }      void ThreadedWorkCulling()     {         _threadRunning = true;         bool workDone = false;         // This pattern lets us interrupt the work at a safe point if neeeded.         while (_threadRunning && !workDone)         {              Thread.Sleep(1);             for (int objectIndex = 0; objectIndex < objectDatas.Length; objectIndex++)             { //for each object                 ObjectData thisObject = objectDatas[objectIndex];                 bool culled = false;                 if (thisObject.rendering == false)                     continue;                   if ((thisObject.dirX * camDir.x) + (thisObject.dirY * camDir.y) + (thisObject.dirZ * camDir.z) < 0) //dot product is less than 0                 {                     culled = true;                 }                 thisObject.culled = culled;             }                          // Do Work...         }         _threadRunning = false;     }      void ThreadedWorkCulling2()     {         _threadRunning = true;         bool workDone = false;          // This pattern lets us interrupt the work at a safe point if neeeded.         while (_threadRunning && !workDone)         {              Thread.Sleep(1);              List<ThreadedObstacle> obstacleIndexes = new List<ThreadedObstacle>();
            for (int i = 0; i < threadedObstacles.Count; i++)
            {
                ThreadedObstacle t = threadedObstacles[i];
                if (t != null)
                {
                    obstacleIndexes.Add(t);
                    t.sumRad = t.radius - t.offset;
                    t.dir = t.pos - camPos;
                    t.dirNorm = t.dir.normalized;
                    t.dist = t.dir.magnitude;
                    t.cosAngle = Mathf.Cos(Mathf.Tan(t.sumRad / t.dist));
                }             }         int obstaclesCount = obstacleIndexes.Count;         ThreadedObstacle[] obstaclesArray = obstacleIndexes.ToArray();             for (int objectIndex = 0; objectIndex < objectDatas.Length; objectIndex++)
            { //for each object
                ObjectData thisObject = objectDatas[objectIndex];
                bool hidden = false;
                if (thisObject.rendering == false)
                    continue;
                if (thisObject.culled == true)
                    continue;

                Vector3 objectPosition = thisObject.position;
                float distance = thisObject.distanceFromCamera;


                int numObstacles = threadedObstacles.Count;
                for (int i = 0; i < obstaclesCount; i++)
                {
                    ThreadedObstacle obstacle = obstaclesArray[i];                     if (obstacle.dist < distance)                     { //If the obstacle is closer to the camera
                        Vector3 dirNorm = obstacle.dirNorm;
                        float dotProduct = (dirNorm.x * thisObject.dirNormX) + (dirNorm.y * thisObject.dirNormY) + (dirNorm.z * thisObject.dirNormZ);

                        if (dotProduct > obstacle.cosAngle)                         {                             hidden = true;                         }                     }                 }

                objectDatas[objectIndex].hidden = hidden;             }              // Do Work...         }         _threadRunning = false;     }       void OnDisable()     {         // If the thread is still running, we should shut it down,         // otherwise it can prevent the game from exiting correctly.         if (_threadRunning)         {             // This forces the while loop in the ThreadedWork function to abort.             _threadRunning = false;              // This waits until the thread exits,             // ensuring any cleanup we do after this is safe.              _thread3.Join();             _thread2.Join();             _thread.Join();         }          // Thread is guaranteed no longer running. Do other cleanup tasks.     }       class LODObject     {         public List<LODElement> lodElements = new List<LODElement>();     }      class LODElement     {         public List<MatrixList> splinteredMatrixLists = new List<MatrixList>();         public void AddMatrix(Matrix4x4 newMatrix, int ID)         {              int currentSplinter = 0;             bool foundNewList = false;             while (foundNewList == false)             {                 if (splinteredMatrixLists[currentSplinter].matrixData.Count == 1010)                 {                     currentSplinter++;                     if ((splinteredMatrixLists.Count - 1) < currentSplinter)                     {                         splinteredMatrixLists.Add(new MatrixList());                     }                 }                 else                 {                     foundNewList = true;                 }             }              splinteredMatrixLists[currentSplinter].matrixData.Add(newMatrix);             splinteredMatrixLists[currentSplinter].objectIDS.Add(ID);         }         public void RemoveMatrix(int id)         {
            for (int i = 0; i < splinteredMatrixLists.Count; i++)             {                 MatrixList matrixList = splinteredMatrixLists[i];                 List<int> alloc = matrixList.objectIDS;                 int allocSize = alloc.Count;                  for (int x = 0; x < allocSize; x++)
                {                     if (alloc[x] == id)
                    {                         matrixList.matrixData.RemoveAt(x);                         matrixList.objectIDS.RemoveAt(x);                         return;                     }                 }
            }         }         public LODElement()         {             splinteredMatrixLists.Add(new MatrixList());         }     }     class MatrixList { public List<Matrix4x4> matrixData = new List<Matrix4x4>(); public List<int> objectIDS = new List<int>(); }      public struct BetterVector3{         public float x, y, z;         public BetterVector3(float xx,float yy,float zz){             x = xx;             y = yy;             z = zz;         }     }     public class ObjectData     {         public Vector3 position;         public Quaternion rotation;         public Vector3 scale;         public Matrix4x4 matrix;         public int id;         public int currentLOD;         public bool rendering = true;         public bool culled;         public bool hidden;         public float distanceFromCamera;         public float dirX, dirY, dirZ;         public float dirNormX, dirNormY, dirNormZ;     }  }  